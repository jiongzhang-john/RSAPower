import math
import warnings
import numpy as np
from functools import partial
from einops import rearrange
from timm.models.layers import DropPath

import torch
import torch.nn as nn
from torch.nn import functional as F


class ConvNormAct(nn.Module):
    def __init__(self, in_ch, out_ch, kernel_size=3, stride=1, padding=0,
                 groups=1, dilation=1, bias=False, norm=nn.BatchNorm2d, act=nn.GELU, preact=False):

        super().__init__()
        assert norm in [nn.BatchNorm2d, nn.InstanceNorm2d, True, False]
        assert act in [nn.ReLU, nn.ReLU6, nn.GELU, nn.SiLU, True, False]

        self.conv = nn.Conv2d(
            in_channels=in_ch,
            out_channels=out_ch,
            kernel_size=kernel_size,
            stride=stride,
            padding=padding,
            groups=groups,
            dilation=dilation,
            bias=bias
        )
        if preact:
            self.norm = norm(in_ch) if norm else nn.Identity()
        else:
            self.norm = norm(out_ch) if norm else nn.Identity()
        self.act = act() if act else nn.Identity()
        self.preact = preact

    def forward(self, x):

        if self.preact:
            out = self.conv(self.act(self.norm(x)))
        else:
            out = self.act(self.norm(self.conv(x)))

        return out


class BasicBlock(nn.Module):
    def __init__(self, in_ch, out_ch, stride=1, norm=nn.BatchNorm2d, act=nn.GELU, preact=False):
        super().__init__()
        assert norm in [nn.BatchNorm2d, nn.InstanceNorm2d, True, False]
        assert act in [nn.ReLU, nn.ReLU6, nn.GELU, nn.SiLU, True, False]

        self.conv1 = ConvNormAct(in_ch, out_ch, 3, stride=stride, padding=1, norm=norm, act=act, preact=preact)
        self.conv2 = ConvNormAct(out_ch, out_ch, 3, stride=1, padding=1, norm=norm, act=act, preact=preact)

        self.shortcut = nn.Sequential()
        if stride != 1 or in_ch != out_ch:
            self.shortcut = ConvNormAct(in_ch, out_ch, 1, norm=norm, act=act, preact=preact)

    def forward(self, x):
        residual = x

        out = self.conv1(x)
        out = self.conv2(out)

        out += self.shortcut(residual)

        return out


class SEBlock(nn.Module):
    def __init__(self, in_ch, out_ch, reduction=16):
        super().__init__()
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.fc = nn.Sequential(
            nn.Conv2d(in_ch, in_ch // reduction, kernel_size=1, bias=False),
            nn.ReLU(inplace=True),
            nn.Conv2d(in_ch // reduction, out_ch, kernel_size=1, bias=False),
            nn.Sigmoid()
        )

    def forward(self, x):
        b, c, _, _ = x.size()
        y = self.avg_pool(x)
        y = self.fc(y)

        return x + x * y.view(b, c, 1, 1)


class inconv(nn.Module):
    def __init__(self, in_ch, out_ch, block=BasicBlock):
        super().__init__()
        self.conv1 = nn.Conv2d(in_ch, out_ch, kernel_size=3, padding=1, bias=False)
        self.conv2 = block(out_ch, out_ch)

    def forward(self, x):
        out = self.conv1(x)
        out = self.conv2(out)

        return out


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                      "The distribution of values may be incorrect.",
                      stacklevel=2)

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor.uniform_(2 * l - 1, 2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
        return tensor


def trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):
    r"""
    Fills the input Tensor with values drawn from a truncated
    normal distribution. The values are effectively drawn from the
    normal distribution :math:`\mathcal{N}(\text{mean}, \text{std}^2)`
    with values outside :math:`[a, b]` redrawn until they are within
    the bounds. The method used for generating the random values works
    best when :math:`a \leq \text{mean} \leq b`.
    Args:
        tensor: an n-dimensional `torch.Tensor`
        mean: the mean of the normal distribution
        std: the standard deviation of the normal distribution
        a: the minimum cutoff value
        b: the maximum cutoff value
    Examples:
        >>> w = torch.empty(3, 5)
        >>> nn.init.trunc_normal_(w)
    """
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


class GELU(nn.Module):
    def __init__(self):
        super(GELU, self).__init__()

    def forward(self, x):
        return 0.5 * x * (1 + torch.tanh(np.sqrt(2 / np.pi) * (x + 0.044715 * torch.pow(x, 3))))


class OverlapPatchEmbed(nn.Module):
    def __init__(self, patch_size=7, stride=4, in_chans=3, embed_dim=768):
        super().__init__()
        patch_size = (patch_size, patch_size)

        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=patch_size, stride=stride,
                              padding=(patch_size[0] // 2, patch_size[1] // 2))
        self.norm = nn.BatchNorm2d(embed_dim)

        self.weight_fine = nn.Sequential(
            nn.Conv2d(in_chans, embed_dim, kernel_size=3, stride=1,
                      padding=1, groups=in_chans),
            nn.GELU(),
            nn.Conv2d(embed_dim, embed_dim, kernel_size=1, stride=1),
            nn.Sigmoid()
        )

        self.weight_coarse = nn.Sequential(
            nn.Conv2d(embed_dim, embed_dim, kernel_size=3, stride=1,
                      padding=1, groups=embed_dim),
            nn.GELU(),
            nn.Conv2d(embed_dim, embed_dim, kernel_size=1, stride=1),
            nn.Sigmoid()
        )

    def forward(self, x):
        ins = x

        x = self.proj(x)
        _, _, H, W = x.shape
        x = self.norm(x)

        ins_pool = F.adaptive_max_pool2d(ins, (H, W))

        mask_f = self.weight_fine(ins_pool)
        mask_c = self.weight_coarse(x)
        mask = mask_f + mask_c

        return x, H, W, mask


class Attention(nn.Module):
    def __init__(self, dim, num_heads=8, qkv_bias=False, qk_scale=None, attn_drop=0., proj_drop=0., sr_ratio=1):
        super().__init__()
        assert dim % num_heads == 0, f"dim {dim} should be divided by num_heads {num_heads}."

        self.dim = dim
        self.num_heads = num_heads
        head_dim = dim // num_heads
        self.scale = qk_scale or head_dim ** -0.5

        self.q = nn.Linear(dim, dim, bias=qkv_bias)

        self.sr_ratio = sr_ratio
        if sr_ratio > 1:
            self.spatial_1 = nn.Conv2d(dim, dim, kernel_size=1, stride=1)
            self.spatial_2 = nn.Conv2d(dim, dim, kernel_size=3, stride=1, padding=1, groups=dim)
            self.spatial_3 = nn.Conv2d(dim, dim, kernel_size=7, stride=1, padding=3, groups=dim)
            self.gelu = nn.GELU()

            self.sr = nn.Conv2d(dim, dim, kernel_size=sr_ratio, stride=sr_ratio)
            self.norm = nn.LayerNorm(dim)
        self.kv = nn.Linear(dim, dim * 2, bias=qkv_bias)

        self.attn_drop = nn.Dropout(attn_drop)

        self.proj = nn.Linear(dim, dim)
        self.proj_drop = nn.Dropout(proj_drop)

        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()

    def forward(self, x, H, W):
        B, N, C = x.shape
        q = self.q(x).reshape(B, N, self.num_heads, C // self.num_heads).permute(0, 2, 1, 3)

        if self.sr_ratio > 1:
            x_ = x.permute(0, 2, 1).reshape(B, C, H, W)

            x_1 = self.spatial_1(x_)
            x_2 = self.spatial_2(x_)
            x_3 = self.spatial_3(x_)
            x_m = x_1 + x_2 + x_3
            x_m = self.gelu(x_m)

            x_ = self.sr(x_m)

            x_ = x_.reshape(B, C, -1).permute(0, 2, 1)
            x_ = self.norm(x_)

            kv = self.kv(x_).reshape(B, -1, 2, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4)
        else:
            kv = self.kv(x).reshape(B, -1, 2, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4)

        k, v = kv[0], kv[1]

        attn = (q @ k.transpose(-2, -1)) * self.scale
        attn = attn.softmax(dim=-1)
        attn = self.attn_drop(attn)

        x = (attn @ v).transpose(1, 2).reshape(B, N, C)

        x = self.proj(x)
        x = self.proj_drop(x)

        return x


class MHCA(nn.Module):
    """
    Multi-Head Convolutional Attention
    """

    def __init__(self, out_channels):
        super(MHCA, self).__init__()

        self.group_conv3x3 = nn.Conv2d(out_channels, out_channels, kernel_size=3, stride=1,
                                       padding=1, groups=out_channels, bias=False)
        self.norm = nn.BatchNorm2d(out_channels)
        self.act = nn.GELU()
        self.projection = nn.Conv2d(out_channels, out_channels, kernel_size=1, bias=False)

        self.se = SEBlock(out_channels, out_channels)

    def forward(self, x):
        out = self.group_conv3x3(x)
        out = self.norm(out)
        out = self.act(out)
        out = self.projection(out)

        out = self.se(out)
        return out


class Mlp(nn.Module):
    def __init__(self, in_features, out_features=None, mlp_ratio=4., drop=0.):
        super().__init__()
        hidden_dim = in_features * mlp_ratio or in_features
        out_features = out_features or in_features
        self.conv1 = nn.Conv2d(in_features, hidden_dim, kernel_size=1, bias=False)
        self.conv3x3 = nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=1, padding=1, groups=hidden_dim,
                                 bias=True)
        self.act = nn.GELU()
        self.conv2 = nn.Conv2d(hidden_dim, out_features, kernel_size=1, bias=False)
        self.drop = nn.Dropout(drop)

    def forward(self, x):
        x = self.conv1(x)
        x = self.conv3x3(x)
        x = self.act(x)
        x = self.drop(x)
        x = self.conv2(x)
        x = self.drop(x)
        return x


class ConvFormer(nn.Module):

    def __init__(self, in_channels, out_channels, num_heads=4, mlp_ratio=4., path_dropout=0, drop=0.):
        super(ConvFormer, self).__init__()
        self.in_channels = in_channels
        self.out_channels = out_channels
        norm_layer = nn.BatchNorm2d
        assert out_channels % num_heads == 0

        self.mhca = MHCA(out_channels, num_heads)
        self.attention_path_dropout = DropPath(path_dropout)

        self.norm = norm_layer(out_channels)
        self.mlp = Mlp(out_channels, mlp_ratio=mlp_ratio, drop=drop)
        self.mlp_path_dropout = DropPath(path_dropout)

    def forward(self, x):
        x = x + self.attention_path_dropout(self.mhca(x))

        out = x
        x = out + self.mlp_path_dropout(self.mlp(out))
        return x


class Block(nn.Module):
    def __init__(self, dim, num_heads, mlp_ratio=4., qkv_bias=False, qk_scale=None, drop=0., attn_drop=0.,
                 drop_path=0., sr_ratio=1):
        super().__init__()
        self.norm1 = nn.BatchNorm2d(dim)

        self.attn = Attention(
            dim, num_heads=num_heads, qkv_bias=qkv_bias, qk_scale=qk_scale,
            attn_drop=attn_drop, proj_drop=drop, sr_ratio=sr_ratio
        )
        self.norm2 = nn.BatchNorm2d(dim)
        self.mlp = Mlp(dim, mlp_ratio=mlp_ratio, drop=drop)

        self.drop_path = DropPath(drop_path) if drop_path > 0. else nn.Identity()

    def forward(self, x, H, W, mask=None):
        B, C, h, w = x.shape
        out = rearrange(self.norm1(x), "b c h w -> b (h w) c")
        out = self.drop_path(self.attn(out, H, W))

        if mask is not None:
            x = x + rearrange(out, "b (h w) c -> b c h w", h=h) * mask
        else:
            x = x + rearrange(out, "b (h w) c -> b c h w", h=h)

        x = x + self.drop_path(self.mlp(self.norm2(x)))
        return x


class Encoder_block(nn.Module):
    def __init__(self, in_chans=3, num_classes=1000, embed_dims=[32, 64, 128, 256, 512],
                 num_heads=[1, 2, 4, 8], mlp_ratios=[4, 4, 4, 4], qkv_bias=False, qk_scale=None, drop_rate=0.,
                 attn_drop_rate=0., drop_path_rate=0., norm_layer=nn.BatchNorm2d,
                 depths=[3, 4, 6, 3], sr_ratios=[8, 4, 2, 1]):
        super().__init__()
        self.num_classes = num_classes
        self.depths = depths

        self.inc = inconv(in_chans, embed_dims[0])

        self.maxpool = nn.MaxPool2d(2)

        dpr = [x.item() for x in torch.linspace(0, drop_path_rate, sum(depths))]

        self.patch_embed1 = OverlapPatchEmbed(patch_size=7, stride=4, in_chans=embed_dims[0], embed_dim=embed_dims[1])

        cur = 0
        self.block1 = nn.ModuleList(
            [
                ConvFormer(
                    in_channels=embed_dims[1], out_channels=embed_dims[1], num_heads=num_heads[0],
                    mlp_ratio=mlp_ratios[0], drop=drop_rate, path_dropout=dpr[cur + i])
                for i in range(depths[0])
            ]
        )
        self.norm1 = norm_layer(embed_dims[1])

        self.patch_embed2 = OverlapPatchEmbed(patch_size=3, stride=2, in_chans=embed_dims[1], embed_dim=embed_dims[2])

        cur += depths[0]
        self.block2 = nn.ModuleList(
            [
                ConvFormer(
                    in_channels=embed_dims[2], out_channels=embed_dims[2], num_heads=num_heads[1],
                    mlp_ratio=mlp_ratios[0], drop=drop_rate, path_dropout=dpr[cur + i])
                for i in range(depths[1] - 1)
            ]
        )
        self.block2.append(
            Block(
                dim=embed_dims[2], num_heads=num_heads[1], mlp_ratio=mlp_ratios[1], qkv_bias=qkv_bias,
                qk_scale=qk_scale,
                drop=drop_rate, attn_drop=attn_drop_rate, drop_path=drop_rate,
                sr_ratio=sr_ratios[1]
            )
        )
        self.norm2 = norm_layer(embed_dims[2])

        self.patch_embed3 = OverlapPatchEmbed(patch_size=3, stride=2, in_chans=embed_dims[2], embed_dim=embed_dims[3])

        cur += depths[1]
        self.block3 = nn.ModuleList(
            [
                ConvFormer(
                    in_channels=embed_dims[3], out_channels=embed_dims[3], num_heads=num_heads[2],
                    mlp_ratio=mlp_ratios[2], drop=drop_rate, path_dropout=dpr[cur + i])
                for i in range(depths[2] - 1)
            ]
        )
        self.block3.append(
            Block(
                dim=embed_dims[3], num_heads=num_heads[2], mlp_ratio=mlp_ratios[2], qkv_bias=qkv_bias,
                qk_scale=qk_scale,
                drop=drop_rate, attn_drop=attn_drop_rate, drop_path=drop_rate,
                sr_ratio=sr_ratios[2]
            )
        )
        self.norm3 = norm_layer(embed_dims[3])

        self.patch_embed4 = OverlapPatchEmbed(patch_size=3, stride=2, in_chans=embed_dims[3], embed_dim=embed_dims[4])

        cur += depths[2]
        self.block4 = nn.ModuleList(
            [
                ConvFormer(
                    in_channels=embed_dims[4], out_channels=embed_dims[4], num_heads=num_heads[3],
                    mlp_ratio=mlp_ratios[3], drop=drop_rate, path_dropout=dpr[cur + i])
                for i in range(depths[3] - 1)
            ]
        )
        self.block4.append(
            Block(
                dim=embed_dims[4], num_heads=num_heads[3], mlp_ratio=mlp_ratios[3], qkv_bias=qkv_bias,
                qk_scale=qk_scale,
                drop=drop_rate, attn_drop=attn_drop_rate, drop_path=drop_rate,
                sr_ratio=sr_ratios[3]
            )
        )
        self.norm4 = norm_layer(embed_dims[4])

    def forward(self, x):
        B = x.shape[0]
        outs = []

        x = self.inc(x)
        outs.append(x)

        x_ = self.maxpool(x)
        outs.append(x_)

        x, H, W, mask_1 = self.patch_embed1.forward(x)
        for i, blk in enumerate(self.block1):
            x = blk.forward(x)

        x = self.norm1(x)
        outs.append(x)

        x, H, W, mask_2 = self.patch_embed2.forward(x)
        for i, blk in enumerate(self.block2):
            if i == len(self.block2) - 1:
                x = blk.forward(x, H, W, mask_2)
            else:
                x = blk.forward(x)

        x = self.norm2(x)
        outs.append(x)

        x, H, W, mask_3 = self.patch_embed3.forward(x)
        for i, blk in enumerate(self.block3):
            if i == len(self.block3) - 1:
                x = blk.forward(x, H, W, mask_3)
            else:
                x = blk.forward(x)

        x = self.norm3(x)
        outs.append(x)

        x, H, W, mask_4 = self.patch_embed4.forward(x)
        for i, blk in enumerate(self.block4):
            if i == len(self.block4) - 1:
                x = blk.forward(x, H, W, mask_4)
            else:
                x = blk.forward(x)

        x = self.norm4(x)
        outs.append(x)

        return outs
